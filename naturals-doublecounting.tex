\section{Двойной счёт}

Напомню, что в графе степенью вершины $\deg(v)$ мы назвали количество рёбер, ей инцидентных.

\begin{thm}
Пусть $V$~--- множество вершин некоторого графа, $e$~--- количество его рёбер. Тогда
$$\sum_{v\in V}\deg(v) = 2e$$
\end{thm}
\begin{proof}
Мы можем пересчитать все рёбра графа двумя способами: собственно, пересчитывая сами рёбра (получим в этом случае $e$), либо же пересчитывая вершины и складывая степени $\deg{v}$. В этом случае, правда, получится, что каждое ребро мы учтём два раза, поскольку каждое ребро инцидентно ровно двум вершинам.
\end{proof}

Это элементарное доказательство является простейшим примером доказательства методом \term{двойного счёта}. Приём этот выглядит всегда одинаково: мы берём некоторый набор объектов и считаем его двумя разными способами, получая в итоге одно и то же значение, но записанное в разном виде. По большому счёту рекурсивные формулы для вычисления числа сочетаний, чисел Белла и чисел Стирлинга, а так же формулы их сумм, доказывались нами именно методом двойного счёта, только мы не произносили этого слова. Остаток этого параграфа мы посвятим разбору ещё нескольких подобных примеров.

\begin{thm}
$$\sum_{k=0}^m {m\choose k}{w\choose n-k} = {m+w\choose n}$$
\end{thm}
\begin{proof}
Пусть у нас имеется $m$ мужчин и $w$ женщин. Нам надо выбрать из них группу $n$ человек. Очевидно, что это можно сделать $m+w\choose n$ способами. С другой стороны, мы можем отдельно рассмотреть все варианты, когда мы выбираем $k$ мужчин и $n-k$ женщин, что даёт нам левую часть.
\end{proof}

\begin{corollary}
$$\sum_{k=0}^n{n\choose k}^2 = {2n\choose n}$$
\end{corollary}
\begin{proof}
Достаточно положить $m=w=n$ и заметить, что ${n\choose k}={n\choose n-k}$.
\end{proof}

\begin{thm}
$$\sum_{k=q}^n{n\choose k}{k\choose q} = 2^{n-q}{n\choose q}$$
\end{thm}
\begin{proof}
Левую часть можно интерпретировать как количество способов выбрать различные подмножества $[n]$ с по крайней мере $q$ элементами, и затем в этих множествах выделить ещё некоторые $q$ элементов. Правая часть даёт ровно ту же самую величину, но в этом случае мы вначале выбираем $q$ помеченных элементов из $[n]$, а затем добавляем к полученному набору один из $2^{n-q}$ подмножеств, составленных из оставшихся элементов.
\end{proof}

\begin{thm}
$$k!\sstirling{n}{k} = k^n - {k \choose 1}(k-1)^n + {k\choose 2}(k-2)^n -\ldots$$
\end{thm}
\begin{proof}
Справа, как мы увидели в конце прошлого параграфа, перечислено количество сюръекций $[n]\to[k]$. Однако, их можно перечислить и по-другому. Пусть $f$~--- некоторая сюръекция, тогда прообразы $f^{-1}(1)$, $f^{-1}(2)$,~... не пусты и задают некоторое разбиение множества $[n]$ на $k$ подмножеств. Таких разбиений существует $\sstirling{n}{k}$ штук. В то же время если $\rho$~--- некоторая перестановка на $[k]$, то $\rho\circ f$ так же задаёт то же самое разбиение множества $[n]$, хотя сюръекция уже будет другой. Поскольку мы имеем $k!$ таких перестановок $[k]$, общее количество сюръекций может быть так же определено как $k!\sstirling{n}{k}$.
\end{proof}

\begin{thm}
$$\sum_{k=1}^n k^2 = {n(n+1)(2n+1)\over 6}$$
\end{thm}
\begin{proof}
Я уже предлагал доказать это утверждение по индукции самостроятельно в упражнении 3.38 по индукции. Сейчас мы докажем эту формулу используя метод двойного счета. Искомую сумму обозначим за $S_n$.

Из того, что $(n+1)^2 = n^2 + 2n + 1$ следует, что каждое следующее слагаемое в сумме $S_n$ равняется предыдущему, увеличенному на $2n+1$. Первый элемент этой суммы 1. Второй элемент суммы по этому разложению мы можем записать как 1+3. Третий элемент как 1+3+5. Продолжая по аналогии, мы можем составить таблицу~3.2:

\begin{table}[h]
\centering
\begin{tabular}{ccccccc}
$1^2$ & $2^2$ & $3^2$ & $4^2$ & $5^2$ & $\ldots$ & $n^2$ \\
\hline
1 & 1 & 1 & 1 & 1 & $\vdots$ & 1 \\
& 3 & 3 & 3 & 3 & $\vdots$ & 3 \\
& & 5 & 5 & 5 & $\vdots$ & 5 \\
& & & 7 & 7 & $\vdots$ & 7 \\
& & & & 9 & $\vdots$ & 9 \\
& & & & & &  $\vdots$  \\
& & & & & &  $2n-1$  \\
\end{tabular}
\caption{Элементы суммы $S_n$}
\end{table}

Первоначальную сумму можно интерпретировать таким образом, что мы вначале в этой таблице складываем стобцы, а затем складываем результаты. Однако, мы можем поступить и по-другому, складывая вначале строки. Если считать строки начиная с верхней, то $i$-ая строка будет состоять из чисел $2i-1$, которых всего будет $n-i+1$ штук. Таким образом получаем:
\begin{align*}
S_n & = \sum_{i=1}^n (n-i+1)(2i-1)\\
& = \sum_{i=1}^n (2in - n - 2i^2 + i + 2i - 1)  \\
& = (2n+3)\sum_{i=1}^n i - 2\sum_{i=1}^n i^2 - n(n+1) \\
& = (2n+3){n(n+1)\over 2} - 2S_n - n(n+1)
\end{align*}
Здесь мы в последней строчке воспользовались формулой для треугольных чисел. Слагаемое $2S_n$ можно <<перенести>> в левую часть уравнения. Получаем:
\begin{align*}
3S_n = {n(n+1)(2n+1)\over 2}
\end{align*}
Разделив теперь обе части на 3 получаем результат.
\end{proof}

Мы до сих пор не сталкивались с переносом слагаемых в уравнениях, это доказательство~--- первый случай. Школьное правило гласит, что любое слагаемое может быть перенесено в другую часть уравнения с противоположным знаком. Это действительно так и я на всякий случай объясню почему. Пусть у нас есть сумма
\begin{equation}\label{ndc:1}
x+y = z
\end{equation}
Знак равенства по сути означает, что слева и справа стоят одинаковые значения, только записанные по-разному. А раз они одинаковые, то применив к ним одинаковые операции, мы так же получим разные значения. Например, мы по этим соображениям можем умножать обе части уравнения на одно и то же число, возводить в одинаковую степень и, в том числе, вычитать из обоих частей одно и то же значение. Вычтя из \eqref{ndc:1} значение $y$ получаем
$$x + y - y = z - y$$
но поскольку $y-y=0$, окончательно получаем
$$x = z - y$$
По сути мы получили то что утрвеждает школьное правило: <<перенесли>> $y$ в другую сторону со сменой знака.

Вернёмся, однако, к двойному счёту. Очень легко можно получить следующую интересную формулу (довольно, правда, бесполезную) для суммы степеней.

\begin{thm}
$$\sum_{i=1}^n i^k = \sum_{j=1}^n {n \choose j}\sstirling{k+1}{j}(j-1)!$$
\end{thm}
\begin{proof}
Рассмотрим множество последовательностей длины $k+1$, таких что все элементы в ней положительны и не превосходят $n$, причём последний элемент последовательности по совместительству максимален.

С одной стороны, если максимальный элемент последовательности $i$ (он же и последний), то оставшиеся $k$ элементов мы можем выбрать произвольным образом от 1 до $i$. Итого получаем $i^k$ таких последовательностей. Учитывая, что $i$ произвольно, сумма, данная в утверждении теоремы слева, перечисляет все интересующие нас последовательности.

С другой стороны мы можем предположить, что всего последовательность состоит из $j$ различных чисел (они могут повторяться). Способов выбрать эти числа $n\choose j$. После этого всю последовательность мы должны разбить на $j$ групп, элементы в каждой из которых будут равны. Итого таких разбиений имеется $\sstirling{k+1}{j}$. Нам осталось присвоить этим группам элементов значения из выбранных $j$ чисел. Учитывая, что последнее число всегда максимально, нам остаётся назначить $j-1$ значение, а способов сделать это столько же, сколько существует перестановок, то есть $(j-1)!$.
\end{proof}

\begin{definition}
Граф называется \term{связным}, если в нём существует путь между любыми двумя вершинами.
\end{definition}

\begin{definition}
\term{Деревом} называется связный граф без циклов.
\end{definition}

Деревья часто применяются в компьютерных системных поиска. Самый распространённый вариант~--- это двоичные деревья поиска, которые представляют собой следующую структуру: каждая вершина дерева обладает некоторым значением и, возможно, тремя гранями, называемых ветвями. Одна ветвь ведёт в направлении корня, другая ветвь, называемая левой, ведёт ко всем вершинам со значениями, меньшими чем текущее, а вторая ветвь, называемая правой, ведёт к большим значениям. Если предположить, что значения~--- это строки, то их порядок может восприниматься как алфавитный. Пример такого бинарного дерева поиска представлен на рисунке 3.11.

\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, rectangle, black, font=\sffamily\bfseries, draw=white,
    fill=white},% arbre rouge noir, noeud noir
}

\begin{figure}[h]
\centering
\begin{tikzpicture}[->,level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_n] {Николай}
    child{ node [arn_n] {Евгения} 
            child{ node [arn_n] {Авдотья}}
            child{ node [arn_n] {Жанна}}                            
    }
    child{ node [arn_n] {Роман}
            child{ node [arn_n] {Ольга}}
            child{ node [arn_n] {Света}}
    }
; 
\end{tikzpicture}
\caption{Бинарное дерево поиска}
\end{figure}

Предположим, что в дереве на рисунке 3.11 так же в каждом узле дерева записан телефон, и что мы захотели найти телефон Ольги. Если бы мы просматривали все телефоны подряд, то в случае их упорядоченности по алфавиту, прежде чем мы наткнулись бы на Олин телефон, нам пришлось бы проверить шесть записей. Однако, вместо этого мы могли бы искать телефон в дереве, двигаясь от корня: вначале мы увидели бы, что имя Ольга должно идти после имени Николай, что значит, что мы должны искать по правой ветви от корня, где мы встречаем имя Роман. Ольга идёт раньше Романа по алфавиту, поэтому мы продолжаем искать её в левой ветви, где и находим её телефон. Итого нам потребовалось три шага поиска: вдвое быстрее чем при последовательном переборе.

\begin{exercise}
Пусть мы ищем телефон Фиофанта. Покажите, что при последовательном поиске нам потребовалось бы 7 шагов, чтобы убедиться, что такого телефона нет, а при поиске  в дереве всего 3 шага.
\end{exercise}

\begin{exercise}
Пусть у нас теперь имеется дерево, в котором записано 2147483647 телефонных номеров. Например, это может база данных ФСБ или ещё какая. Покажите, что используя бинарное дерево поиска, мы можем найти любой телефон (или убедиться, что его нет в базе) максимум за 31 шаг.
\end{exercise}

Последнее упражнение показывает, что использование деревьев может здорово упростить поиск информации (зачастую ускорение получается в миллионы раз). Собственно очень похожим образом устроены почти все базы данных, и без деревьев не было бы ни компании Гугл, ни, наверное, вообще компьютерной техники в современном её виде. Чтобы уметь анализировать скорость работы алгоритмов, нам прежде всего необходимо уметь пересчитывать все деревья.

Бинарные деревья~--- это в общем-то частный случай дерева. Как перечислить все возможные деревья поиска мы поймём позже в нашем курсе (мы изучим общие подходы), а пока что же мы перечислим  просто все возможные деревья с $n$ вершинами. При изучении следующего доказательства важно иметь ввиду следующие уточнения постановки задачи, которые мы подразумеваем:
\begin{enumerate}
\item Дерево не обладает корнем; все вершины равнозначны;
\item Вершины деревьев имеют определённые метки (данные от 1 до $n$), то есть даже если два дерева имеют одинаковую форму внешне, но вершины имеют разные именования, мы рассматриваем эти деревья как различные;
\item Каждая вершина может иметь произвольное количество инцидентных рёбер;
\item Рёбра, в отличие от бинарного дерева поиска, никак не упорядочены, то есть понятия <<левое>> или <<правое>> тут не имеет значения.
\end{enumerate}

Если изменить любое из этих условий, то формула для количества деревьев будет уже совершенно другой, но пока мы не будем рассматривать эти случаи.

\begin{table}[h]
\centering
\begin{tabular}{c|ccccc}
$x$ & 1 & 2 & 3 & 4 & 5 \\
\hline
$f(x)$ & 4 & 1 & 1 & 2 & 4
\end{tabular}
\caption{Пример функции $f$}
\end{table}

\begin{thm}
Существует $n^{n-2}$ деревьев с $n$ вершинами.
\end{thm}
\begin{proof}
Подсчитаем количество функций $f:[n]\to[n]$ двумя способами. С одной стороны количество таких функций $n^n$, это тривиальная теорема, рассмотренная нами в~\S~3.1. Попробуем теперь подсчитать количество функций $f$, сопоставив каждой функции некоторое дерево. Это довольно сложное рассуждение, поэтому будем рассматривать его на примере функции $f$, значения которой заданы в таблице~3.3. Пусть
$$C = \{x \in[n]| \exists k\ f^k(x) = x\}$$
то есть это множество таких элементов $x$ из $[n]$, что применяя к ним $f$ последовательно несколько раз, мы в какой-то момент получим тот же $x$. Для функции из нашего примера $C = \{1,2,4\}$.

Если упорядочить по возрастанию элементы $C$ и рассмотреть ограничение на нём $f|_C$, то эта функция будет действовать как перестановка $C$, которую мы можем записать строкой (в примере будет $f|_C = 412$). Теперь, выбрав в качестве вершин графа элементы $[n]$, мы можем соединить вершины из $C$ в порядке, заданном перестановкой. Элементы $[n]\backslash C$ пока правда остаются изолированными. Чтобы сформировать из них дерево, для каждого значения $x\in [n]\backslash C$, если $f(x)=y$ добавим ребро $xy$. Для функции из примера это будут рёбра 31 и 54. Получившееся дерево изображено на рисунке~3.12.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\def\point{node [circle, draw, fill, inner sep = 0, minimum size = .1cm] }
\draw (0, 0) \point (p1) {};
\draw (1cm, 0cm) \point (p2) {};
\draw (0cm, 1cm) \point (p3) {};
\draw (-1cm, 0cm) \point (p4) {};
\draw (-1cm, -1cm) \point (p5) {};

\node [below] at (p1) {1};
\node [right] at (p2) {2 (конец)};
\node [left] at (p3) {3};
\node [left] at (p4) {(начало) 4};
\node [right] at (p5) {5};

\draw (p1) -- (p2);
\draw (p1) -- (p3);
\draw (p1) -- (p4);
\draw (p4) -- (p5);
\end{tikzpicture}
\caption{Дерево, построенное по функции $f$}
\end{figure}

Надо теперь показать, что и для каждого дерева мы можем задать функцию. Это делается в полной аналогии: вначале выбираем в дереве условные <<начало>> и <<конец>> (внимание!) и находим путь от начала к концу. Вершины этого пути задают множество $C$, а последовательность вершин перестановку $f|_C$. Для вершин $x$, не вошедших в этот путь, в качестве значения $f(x)$ выбираем следующую вершину по пути от $x$ до <<конца>> дерева.

Остаётся лишь заметить, что заданная конструкция даёт нам не просто дерево, а дерево с выбранными <<началом>> и <<концом>>. У дерева с $n$ вершинами есть $n^2$ способов определить начало и конец, поэтому количество произвольных деревьев в $n^2$ раз меньше, чем количество функций $[n]\to[n]$. (По-хорошему так же надо более чётко указать, что соответствие деревьев и функций в данном случае действительно однозначное, но это не сложно и я оставляю это в качестве упражнения читателю).
\end{proof}

Приведу для обшего развития несколько упражений на деревья. Эти задачи используют разные техники, которые мы рассматривали, и решаться могут по-разному. В задачах под деревьями будут пониматься бинарные деревья с корнем. \term{Листьями} мы будем называть вершины без потомков. Рёбра деревьев будут неупорядочены, но листья (и только они) будут иметь метки.

\begin{exercise}
Докажите, что дерево с $n$ листьями, описанное выше, будет иметь $2n-2$ рёбер.
\end{exercise}

\begin{exercise}
Докажите, что деревьев указанного вида с $n$ листьями существует
$$(2n - 1)!!$$
штук, где $n!!$ обозначает \term{двойной факториал}:
$$n!! = n\cdot (n-2) \cdot (n-4) \cdot\ldots$$
\end{exercise}

\begin{exercise}
Рассморим множество $[n]$. Сколько существует способов разбить это множество на пары? (Если $n$ нечётное, то один элемент должен остаться без пары).
\end{exercise}

\begin{exercise}
Докажите, что для чётного $n=2k$
$$n!! = 2^kk!$$
\end{exercise}

\begin{exercise}
Создал боженька $n$ бесполых бессмертных существ и сказал им: <<Плодитесь и размножайтесь!>> Зачать ребёнка (опять же бесполого и бессмертного) может любая пара существ, если они не являются родственниками. <<Родственниками>> существа являются лишь в том случае, если они потомки одного и того же подмножества $n$ первоначальных существ. Сколько всего существ наплодится таким образом? 
\end{exercise}