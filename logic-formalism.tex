\section{Формализм}

До сих пор все наши рассуждения были главным образом интуитивными, мы апеллировали к каким-то физическим образам и вводили нестрогие вспомогательные понятия вроде множеств (само понятие множества определяется в математике строго, но мы это сделаем лишь в следующей главе). Такой подход нельзя назвать безупречным с математической точки зрения, поэтому в этой главе мы формально введём уже рассматриваемые нами ранее понятия.  Вернее, не совсем формально, но я покажу, как это в целом делается. Этот параграф необязателен для дальнейшего понимания книги, но тем, кому важно доскональное понимание основ, он сможет немного помочь.

Состоять наше изложение логики будет из трёх частей: языка (то, как мы записываем предложения), синтаксиса (правила вывода одного предложения из другого) и семантики (наделение предложений предполагаемым смыслом). Главным образом причём мы будем говорить именно о языке, поскольку синтаксис и семантику мы в принципе уже рассмотрели и формальное изложение отличается не сильно.

\subsection{Язык}

Как мы уже отмечали, когда мы даём какое-то определение, мы всегда вынуждены пользоваться другими определениями. В конечном итоге мы обязаны ввести какое-то понятие, которое мы никак не определяем. Это называется <<принципом Мюнгхаузена>>: если бы мы не начинали построение математики от какого-то неопределяемого понятия, то получилось бы, что наши определения как-то зависимы друг от друга: условно говоря определение А базировалось бы на определении Б, а определение Б на определении А, и это в самом явном случае (зависимости могли бы быть самыми сложными теоретическими, но такие определения всегда были бы ошибочны). Хотя в определениях в общем-то допускаются перекрёстные ссылки друг на друга или даже самих на себя, где-то в любом случае любое определение должно ссылаться на понятие, которое мы ещё не определили.

В качестве понятия, которое мы никак не будем определять, у нас будет выступать \term{<<символ>>}. С точки зрения интуиции, символ~--- это некоторая закорючка на бумаге. С точки же зрения логики это понятие, которое мы принимаем без попыток понять что это.

\begin{definition}
\term{Алфавитом} назовём набор символов.
\end{definition}

\begin{example}
Примером алфавитов может служить русский или английский алфавит.
\end{example}

\begin{example}
Для нужд логики мы определим алфавит, состоящий из символов $\land$, $\lor$, $\to$, $\neg$, $\oplus$, $\leftrightarrow$, $\forall$, $\exists$, $=$, (, ) а так же всех символов английского языка, как строчных, так и заглавных. Сам этот алфавит будем обозначать как $\Sigma$.
\end{example}

Да, опять же нам надо как минимум определить что значит слово <<набор>>, используемое в определении алфавита. Это возможно сделать, но в такую степень формализма мы уже не будем углубляться, и если вы в дальнейшем найдёте где-то подобные дырки в определениях, отнеситесь к этому с пониманием. Мы могли бы привести все определения, но рассказ просто очень сильно тогда затянулся бы. Я же излагаю сейчас лишь то, что реально имеет какое-то отношение к практике и показываю как в целом строится фундамент логики.

\begin{definition}
\term{Строкой} (или так же \term{словом}) называется конечная упорядоченная последовательность символов (возможно, пустая) некоторого алфавита. Пустая строка для удобства обозначается как $\epsilon$.
\end{definition}

Строками алвавита $\Sigma$, определённого выше, являются например такие выражения как <<$\land\land P\oplus\leftrightarrow$>>. Строками русского алфавита будут такие последовательности как <<аплотфдц>>, а английского такие как <<shehs>>. Это совершенно бессмысленный набор символов, и отсюда ясно, что нам необходимо как-то из всех возможных строк выделить допустимые.

\begin{definition}
Набор слов (возможно, бесконечный) называется \term{языком}.
\end{definition}

Простейший, но одновременно с тем и почти бесполезный способ задания языка~--- это простое перечисление всех строк алфавита. В каких-то частных случаях это было бы возможно, но в целом это неинтересные либо непрактичные примеры. Очевидно, что перечислить все возможные предложения логики (или любого другого языка) без использования каких-то специальных механизмов явно невозможно.

\begin{definition}
\term{Грамматикой} называется некоторое формальное описание структуры допустимых слов языка.
\end{definition}

Это довольно нечёткое определение и как именно грамматику задавать может решать каждый сам для себя. Например, мы могли бы сконструировать язык, описывающий все возможные положения игры крестики-нолики. В качестве алфавита мы выберем набор $\{x, o, ?,1, 2\}$, а в качестве языка условимся называть все строки длины 10 этого алфавита, в которых первым символом идёт либо 1 либо 2 (что обозначает игрока, которому принадлежит ход), а оставшиеся символы будут обозначать подряд все клетки поля, где помимо крестиков и ноликов мы могли бы ставить символ $?$ для незанятых клеток. Примером такого слова может служить строка <<20?0?x???xx>>~--- она описывает ситуацию, изображённую в таблице~1.11.

\begin{table}[h]
\centering
\begin{tabular}{c | c | c}
o & & o\\
\hline
  & x & \\
\hline
 & x & x
\end{tabular}
\caption{Ход второго игрока}
\end{table}

Мы могли бы перечислить все слова языка крестиков-ноликов, но это было бы сложно, так как возможных слов, которые нам подходят, слишком много. Вместо этого мы явно указали, что вначале указывается чей ход, а затем позиция в девяти клетках. Такое описание можно считать грамматикой языка крестиков-ноликов.

В общем случае для задания грамматик и работы с ними существует целый ряд стандартных механизмов, которыми занимается раздел математики под названием <<Теория формальных языков>> и этими механизмами удобно пользоваться.

Самый простой способ задания грамматики языка~--- это разбить предложения языка на составные единицы и указать правила, по которым они составляются. Такие грамматики называются \term{контекстно-свободными}. Тут можно вспомнить уроки русского языка в школах: все изучали, что предложение состоит из составных частей вроде подлежащего, сказуемого, дополнения, вводного предложения, деепричастного оборота. Определения частей языка могут быть и рекурсивными, то есть ссылающимися на самих себя. Так, предложением является так же и набор из нескольких предложений, соединённых союзами. Эти элементы языка так же описываются с помощью других языковых элементов: подлежащее может быть представлено местоимением, существительным, числительным и т.п.

Таким же путём мы сейчас опишем грамматику предложений логики. Для удобства мы будем записывать правила в форме, подобной следующей:
$$a \to bad | ef | g$$
Здесь $a$~--- это объект языка, вертикальными чертами разделены различные варианты чем $a$ может являться, а между вертикальных черт записывается конкретная форма. Запись может разбиваться на несколько строк.

\begin{example}
Правило, приведённое выше говорит, что, например, запись  $bbefdd$ является элементом $a$. Действительно, $ef$ является элементом $a$. То есть мы можем сказать, что $bbefdd = bbadd$. Теперь, $bad$ в середине строки так же является элементом $a$: $bbadd = bad$. Собственно мы получили, что изначальная строка является элементом $a$.
\end{example}

Я не буду выписывать грамматику целиком, определив лишь базовые конструкции для понятия \term{формулы}:\\
\\
Формула $\to$ атом | $\neg$ формула\\
\hspace*{2cm}| формула $\land$ формула | формула $\lor$ формула\\
\hspace*{2cm}| формула $\to$ формула | формула $\leftrightarrow$ формула\\
\hspace*{2cm}| $\forall$ \term{переменная} формула | $\exists$ \term{переменная} формула\\
Атом $\to$ терм = терм | \term{предикат} (списоктермов)\\
Терм $\to$ \term{константа} | \term{операция} (списоктермов)\\
Списоктермов $\to$ терм списоктермов | $\epsilon$\\
\\
Слова, которые я выделил курсивом (предикат, переменная, операция, константа)~--- это некоторые символы, которые мы каким-то произвольным образом разбили в группы. В каждой конкретной ситуации вы разбиваем эти символы по-разному. Например, так:\\
\\
Предикат $\to$ P | Q | R| $\ldots$\\
Переменная $\to$ x | y | z| $\ldots$\\
Операция $\to$ f | g | h | $\ldots$\\
Константа $\to$ a | b | c | $\ldots$\\
\\
Это уже целиком зависит от того, как мы собираемся использовать эти символы.

\begin{example}
Давайте разберём формулу $\forall x P(x) \to Q(f(y))$. Эта формула явно имеет вид <<$\forall$ переменная формула>>, в роли переменной выступает $x$, а в роли формулы $P(x) \to Q(f(y))$. Последняя так же состоит из двух формул $P(x)$ и $Q(f(y))$, соединённых символом $\to$. Обе эти формулы являются атомами вида <<предикат (списоктермов)>>. В случае $P(x)$ список термов состоит из единственного терма $x$ (более точно~--- из терма $x$ и спискатермов $\epsilon$), а в случае $Q(f(y))$ из единственного терма $f(y)$. $x$ является переменной, а терм $f(y)$ имеет вид <<операция список термов>>. В качестве операции тут выступает $f$, а в качестве терма $y$, который является переменной.
\end{example}

Как видно, простая на вид запись на самом деле, если определять её формально, имеет довольно сложную структуру. Тем не менее для математической строгости мы обязаны это всё определять именно таким образом.

\begin{definition}
Переменная $v$ в составе формулы называется \term{свободной}, если перед этой формулой не написано $\exists v$ или $\forall v$.
\end{definition}

Здесь требуется сделать несколько дополнительных ремарок уже по самому смыслу того, что мы определили.

Во-первых, читателя могло смутить, что мы никак не обмолвились о множествах и пишем теперь не $\forall x\in A$, а просто $\forall x$. Это связано с тем, что теория множеств сама по себе требует определения в терминах логики и мы введём её формально лишь в следующей главе. Теория множеств хороша для интуитивного понимания предикатов, но пользоваться ей прежде, чем она определена, мы не имеем права.

Во-вторых, вас могла смутить запись $P(f(x))$ и термин <<операция>>. Формально это просто правило для записи предложений, интуитивно об этом можно думать как о некотором правиле, которое некоторым термам ставит в соответствие другой терм. Например, опять же воспользовавшись нестрогой интуицией, мы могли бы считать, что операция $f$ сообщает достаток человека. Если предикат $P$ означает достаток свыше миллиона, а $x$~--- это некоторый человек, то формула, выражающая высокий доход человека $x$ будет записываться как $P(f(x))$. Такие конструкции входят традиционно в язык логики, но с точки зрения интуиции и практики о них гораздо лучше рассуждать опираясь на теорию множеств, и поэтому я это оставил для следующей главы.

Ну и в заключение заметим, что введённый нами язык допускает запись $\forall x\ P(x)$, но не допускает записи $\forall P\ P(x)$. Это не просто так, поскольку если бы мы допустили выражения в духе <<для любого предиката>>, то наша логика оказалась бы несколько сложнее. Такая логика используется, но для наших нужд она не пригодится. Для общей информации я лишь замечу, что логика, рассмотренная нами называется \term{логикой первого порядка}, если добавить к ней выражения <<для любого предиката>>, то это будет \term{логика второго порядка}, а если же, наоборот, кванторы убрать вовсе, то получится \term{логика нулевого порядка}. Если из логики нулевого порядка убрать операции и переменные, то получится \term{логика высказываний}. Это всё нам не понадобится в дальнейшем, но упомянуть <<для общего развития>> будет не лишним.

\subsection{Синтаксис}

Язык логики определён, перейдём к синтаксису. Читатель теперь может понять формальное значение правил вроде
$$\alpha, \alpha\to\beta \vdash \beta$$
Здесь в качестве греческих букв может выступать любое предложение, а каждая из записей в левой части определяет структуру предложения, которая соответствует нашей контекстно-свободной грамматике. Символ $\vdash$ означает <<выводимость>>. Обычно для правил вывода  используют какую-то другую нотацию, чтобы не путать правило вывода и выводимость предложения в теории, но мы не будем различать эти понятия специально.

Как мы уже упоминали, мы начинаем с некоторого набора аксиом, которые являются набором предложений языка логики. Применяя правила вывода, мы получаем из них теоремы. Набор всех выводимых теорем называется теорией. Символом $\Gamma$ мы будем обозначать некоторый произвольный набор предложений (для интуиции это удобно рассматривать как некоторый ограниченный набор теорем, выводимых из наших аксиом). В таблице~1.10 мы привели основные правила вывода, не касающиеся кванторов (правила вывода логики высказываний), теперь же мы готовы сформулировать и их.

\term{Universal instantiation (UI)}: Если $\Gamma \vdash \forall x\ P(x)$, то $\Gamma \vdash P(c)$.

Интуитивно это правило очень понятное: если мы доказали, что что-то выполняется для любого элемента, то для конкретного $c$ оно так же будет выполняться, где $c$ может быть как свободной переменной, так и константой.

\term{Existential generalization (EG)}: Если $\Gamma \vdash P(c)$, то $\Gamma\vdash \exists x P(x)$.

Опять же тут довольно всё просто: если мы вывели предложение $P$ для какого-то конкретного $c$, то среди всех возможных элементов найдётся такой, для которого $P$ истинно.

\term{Existential instantiation (EI)}: Если $\Gamma \vdash \exists x\ P(x)$, то $\Gamma \vdash P(c)$.

Это правило работает в том случае, если $c$ не используется ни в каком из предложений $\Gamma$ и не встречается в $P(x)$. Интуиция здесь так же простая: если мы доказали существование некоторого элемента, для которого выполняется $P$, то мы можем ввести для этого элемента специальную константу $c$, при условии, что мы уже не используем это обозначение для чего-то другого.


\begin{example}
Давайте докажем импликацию $(\forall x\ A(x)) \to (\exists x\ A(x))$. Для этого первоначальный набор аксиом $\Gamma$ будем содержать лишь одно предложение $\forall x\ A(x)$.
\begin{enumerate}
\item $\Gamma\vdash \forall x\ A(x)$~--- дано;
\item $\Gamma \vdash A(c)$~--- universal instantiation;
\item $\Gamma, A(c) \vdash \exists A(x)$~--- existential generalization.
\end{enumerate}
\end{example}

И последнее правило:

\term{Unversal generalization (UG)}: Если $\Gamma \vdash P(x)$, то $\Gamma\vdash \forall x\ P(x)$.

Здесь $x$~--- это переменная, не зависящая от предыдущих шагов вывода, $P$~--- формула со свободной переменной. Правило работает только в том случае, если $\Gamma$ не содержит ни одного предложения, содержащего $c$, P не содержит переменных с именем $x$.

Интуитивно это можно интерпретировать так: если нам удалось вывести предложение $P(c)$, где $c$~--- произвольная константа, то мы точно так же могли бы вывести это предложение для любого элемента той теории, которую мы рассматриваем. Кто изучал геометрию в школе, мог заметить такой довольно общий шаблон доказательства теорем: <<Возьмём произвольный треугольник ABC... бла-бла-бла доказательство бла-бла-бла... значит, любой треугольник обладает свойством бла-бла-бла>>. Эта структура и отражает идею правила universal generalization: если нам удалось доказать что-то для произвольного объекта, пусть как-то специально и поименованного, мы можем доказать это для любого объекта и соответственно можем использовать квантор $\forall$.

Независимость переменной $x$ довольно сложно определить и она требует внимательного к себе отношения. Мы можем рассмотреть пример 1.8 в обратном порядке: применяя к $\exists x \ A(x)$ правило EI получим $A(c)$, а к нем можно применить UG, получая $\forall x\ A(x)$. В итоге имеем следствие
$$(\exists x\ A(x)) \to (\forall x\ A(x))$$
которое очевидно ошибочно. Интуитивно ошибка ясна: $c$ во втором шаге зависела от правила EI предыдущего шага, поэтому нам требуется формальный запрет применять правило UG к константам, которые были введены в рассмотрение правилом EI. В нашем случае мы можем использовать формальный приём, связанный с тем, что после шага EI мы получаем формулу, в которой $c$ является не переменной, а константой, а правило UG работает только для переменных. Этот подход используется далеко не всегда, и есть множество других подходов к определению логики первого порядка, которые при полном формальном построении логики оказываются часто лучше, но для наших нужд такой формальный приём будет достаточен.

\begin{example}
Докажем, что можно ввести правило вывода $$(\forall x\ A(x)\to B(x)), (\forall x\ A(x)) \vdash (\forall x\ B(x))$$
Разобьём доказательство на шаги.
\begin{enumerate}
\item $\forall x\ A(x) \to B(x)$ --- дано;
\item $\forall x\ A(x)$ --- дано;
\item $A(c)$ --- UI;
\item $A(c) \to B(c)$ --- UI;
\item $B(c)$ --- из 3 и 4 по modus ponens;
\item $\forall x\ B(x)$ --- UG;
\end{enumerate}
\end{example}

\begin{exercise}
Докажите, что существует тавтология $$\vdash \forall x\ (x\lor\neg x)$$
\end{exercise}

Приведённые пример и упражнение демонстрируют типичное применение правил UG и UI. Как бы формально ни определялась логика в отношении кванторов, целью этих определений всегда является возможность подобных выводов с одновременным отграничением их от правил EG и EI.

\subsection{Семантика}

Семантика~--- это тот смысл, который мы в логику вкладываем. До сих пор всё что мы говорили являлось лишь операциями с символами на бумаге и не более того. Мы могли бы взять язык крестиков-ноликов и ввести правила вывода типа $xx\vdash00$ и $??\vdash01$ и начать доказывать какие-то теоремы. Однако, эти теоремы хоть и были бы формально корректны с точки зрения правил вывода, смысла бы они никакого не несли~--- это были бы просто кружочки и крестики, которые как-то меняются друг на друга. 

Если мы правила вывода в логике придумываем не просто так, а с каким-то умыслом, то говорят, что мы наделяем их семантикой. Это не строгое определение (строго его и не определить, видимо), но более-менее надеюсь, понятное. Так, мы могли бы разрешить лишь те правила вывода для крестиков-ноликов, которые соответствуют возможным ходам игроков, и если бы мы держали в уме, что это не просто символы на бумаге, а закодированное игровое поле, то это было бы семантическим значением.

Логику высказываний мы уже наделили семантикой, когда сказали в первом параграфе, что каждое высказывание является либо истинным либо ложным и задали таблицы истинности для логических операций. Семантика для логики первого порядка~--- это возможные интерпретации системы аксиом. Обычно на практике они задаются с помощью теории множеств, но тут есть проблема, что сама теория множеств задаётся на языке логики. Все эти препятствия в принципе можно попытаться обойти, но это путь скучный и муторный~--- довольно сложно определить всё формально корректно.

Как альтернативу чуть менее распространённую, но более простую, можно задать семантику через модели, как мы их определили в \S~1.5: модель $M$ теории $T$ это просто набор предложений, такой что если $T\vdash\phi$, то $M\models \phi$, а так же для любого $\psi$ либо $M\models \psi$, $M\models \neg\psi$. Этого упрощённого определения мы и будем придерживаться. Здесь у нас получается, что сама семантика определяется в терминах синтаксиса, что не понравится многим философам, но так оно просто проще и мы будем придерживаться этого подхода.

Мы уже упоминали такое важное свойство полноты некоторых логических систем: если для любой модели $M$ теории $T$ предложение истинно, то оно может быть выведено в теории $T$. Есть так же второе не менее важное свойство: если любой конечный набор предложений теории удовлетворим (то есть обладает моделью), то удовлетворима и вся теория. Это свойство называется компактностью и оно крайне важно для многих теорем логики. Из него в частности следует, что любая непротиворечивая теория обладает моделью. Я не буду вдаваться здесь в детали, лишь скажу, что возможно доказать, что логика первого порядка~--- это самая общая из возможных логик, которая удовлетворяет обоими этими свойствами. Если бы мы использовали логику второго порядка или какую-то другую более выразительную логику, то ни теорема о полноте, ни теорема о компактности уже не работали бы (последнюю, впрочем, можно сделать и полной и компактной, если немного ограничить рассматриваемые семантики, что накладывает дальнейшие ограничения).

По большому счёту все доказательства в математике происходят на уровне синтаксиса и мы не используем ничего больше: мы просто выводим одно из другого. Это соответствует обычной аргументации, которую мы используем в спорах на любую тему. Мы произносим набор фраз, из которых делаем какие-то следствия, прибавляя их к тому, что мы принимаем за истину. Семантика как таковая нами не используется ни в математике ни в повседневной речи, хотя конечно мы какой-то смысл всегда и подразумеваем.

Как только мы начинаем обсуждать не само доказательство, а поднимаемся на тот уровень абстракции, когда пытается что-то утверждать о самой используемой логике~--- здесь уже обычно возникают вопросы, связанные с семантикой. Мы не можем чисто синтаксически доказать, что предложение $\phi$ недоказуемо, и чтобы выяснить это, нам надо строить различные интерпретации. Мы будем редко обращаться к таким рассуждениям, ограничившись в дальнейшем буквально несколькими примерами.
